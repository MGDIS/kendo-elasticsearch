{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kendo-elasticsearch.min.js","webpack:///webpack/bootstrap 0d480a7861c0c67886de","webpack:///./src/kendo-elasticsearch.js","webpack:///./src/sort.js","webpack:///./src/groups.js","webpack:///./src/aggregations.js","webpack:///./src/es-utils.js","webpack:///./src/data-items.js","webpack:///./src/filters.js","webpack:///./src/fields.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","length","err","Array","isArray","TypeError","_sort","sort","_groups","groups","_aggregations","aggregations","_filters","filters","_esUtils","esUtils","_dataItems","dataItems","_fields","fields","data","kendo","ElasticSearchDataSource","DataSource","extend","init","initOptions","Error","transport","read","url","readTransport","dataType","method","contentType","_model","schema","model","esMapping","kendoFieldsFromESMapping","fill","_fields$nestedFields","nestedFields","_fields$nestedFields2","_nestedFields","_subTypes","console","log","parameterMap","sortParams","prepareParams","group","columns","esParams","skip","from","take","size","aggregationsOnly","kendo2es","query","filtered","filter","innerHits","esMappingKey","_source","keys","k","esNestedPath","esParentType","esChildType","map","esName","aggs","aggregate","JSON","stringify","parse","response","items","fromHits","hits","doc_count","total","aggregates","es2kendo","grps","serverFiltering","serverSorting","serverPaging","serverAggregates","serverGrouping","fn","fromMapping","_defineProperty","defineProperty","enumerable","configurable","writable","_kendo2es","nestedPath","sortItem","field","esFilterName","order","dir","missing","mode","_prepareParams","arguments","sortArray","constructor","fullSort","forEach","matchingSort","splice","indexOf","concat","previousLevelAggs","previousLevelNestedPath","nextLevelAggs","_kendoGroup2es","nested","path","esFullNestedPath","previousLevelAgg","aggKey","groupAgg","missingAgg","fieldAggregate","groupAggregates","type","esAggName","interval","terms","esGroupAggregates","_parseGroupAggregations","missingNested","groupAggregations","substr","fieldKey","_es2kendo","allGroups","groupAggregation","groupDefs","_esAgg2kendo","fillInGroups","hasSubgroups","buckets","bucketKey","bucket","missingAggregation","groupsMap","groupKeys","key_as_string","count","groupNestedPath","esAggs","aggItem","aggsWrapper","previousPathParts","group_reverse_nested","reverse_nested","split","nestedPathPart","currentPath","join","fullCurrentPath","currentFields","innerHitsFilter","kendoToESAgg","aggType","suffixLength","min","max","sum","average","_innerHits","subTypes","previousLevelInnerHits","_innerHitsFilter","inner_hits","subType","_manageBooleanFilter","booleanFilter","childFilter","bool","must","should","not","has_child","has_parent","$","_fillInGroups","dataItem","fieldValue","Date","groupDefValue","groupDefNextValue","_getValuesFromSource","source","pathParts","values","valueItem","slice","_fromHits","innerPath","hit","hitSource","_id","esNameSplit","duration","moment","startOf","diff","esMultiSplit","esMultiSeparator","splittedItems","innerHitKey","nestedItems","newSplittedDataItems","splittedItem","nestedItem","mergedItem","_splitMultiValues","results","item","itemResults","partialItemResults","val","result","newResult","k2","kendoFilters","logicalConnective","operator","logic","esFilters","esNestedFilters","esFilter","query_string","_filterParam","analyze_wildcard","error","message","exists","esSearchName","esNestedFilter","kendoFilter","subtract","format","add","fieldName","fieldEscaped","_asESParameter","valueEscaped","simpleBinaryOperators","eq","search","lt","lte","gt","gte","esOperator","missingBooleanAsFalse","expression","toISOString","replace","match","escapeSearchValueRegexp","escapeValueRegexp","_fromMapping","mapping","prefix","esPrefix","properties","propertyKey","property","curedPropertyKey","asKendoPropertyKey","prefixedName","subNestedPath","index","esSearchSubField","esFilterSubField","esAggSubField","_fill","esStringSubFields","agg","_result"],"mappings":"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","file":"kendo-elasticsearch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"kendo-elasticsearch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"kendo-elasticsearch\"] = factory();\n\telse\n\t\troot[\"kendo-elasticsearch\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"kendo-elasticsearch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"kendo-elasticsearch\"] = factory();\n\telse\n\t\troot[\"kendo-elasticsearch\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * A Kendo DataSource that gets its data from ElasticSearch.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Read-only, supports paging, filtering, sorting, grouping and aggregations.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\t\n\tvar _sort = __webpack_require__(1);\n\t\n\tvar sort = _interopRequireWildcard(_sort);\n\t\n\tvar _groups = __webpack_require__(2);\n\t\n\tvar groups = _interopRequireWildcard(_groups);\n\t\n\tvar _aggregations = __webpack_require__(3);\n\t\n\tvar aggregations = _interopRequireWildcard(_aggregations);\n\t\n\tvar _filters = __webpack_require__(6);\n\t\n\tvar filters = _interopRequireWildcard(_filters);\n\t\n\tvar _esUtils = __webpack_require__(4);\n\t\n\tvar esUtils = _interopRequireWildcard(_esUtils);\n\t\n\tvar _dataItems = __webpack_require__(5);\n\t\n\tvar dataItems = _interopRequireWildcard(_dataItems);\n\t\n\tvar _fields = __webpack_require__(7);\n\t\n\tvar fields = _interopRequireWildcard(_fields);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar data = kendo.data;\n\t\n\tdata.ElasticSearchDataSource = data.DataSource.extend({\n\t  init: function init(initOptions) {\n\t    if (!initOptions) {\n\t      throw new Error('Options are required to use ElasticSearchDataSource');\n\t    }\n\t\n\t    // Prepare the transport to query ES\n\t    // The only required parameter is transport.read.url\n\t    if (initOptions.transport && initOptions.transport.read && initOptions.transport.read.url) {\n\t      var readTransport = initOptions.transport.read;\n\t      readTransport.dataType = readTransport.dataType || 'json';\n\t      readTransport.method = readTransport.method || 'POST';\n\t      readTransport.contentType = readTransport.contentType || 'application/json';\n\t    } else {\n\t      throw new Error('transport.read.url must be set to use ElasticSearchDataSource');\n\t    }\n\t\n\t    var _model = initOptions.schema && initOptions.schema.model;\n\t    if (!_model) {\n\t      throw new Error('transport.schema.model must be set to use ElasticSearchDataSource');\n\t    }\n\t    if (_model.esMapping) {\n\t      _model.fields = _model.fields || {};\n\t      data.ElasticSearchDataSource.kendoFieldsFromESMapping(_model.esMapping, _model, _model.fields);\n\t    } else {\n\t      if (!_model.fields) {\n\t        throw new Error('transport.schema.model.fields/esMapping must be set');\n\t      }\n\t      fields.fill(_model.fields, _model);\n\t    }\n\t\n\t    // Get sets of nesting levels\n\t\n\t    var _fields$nestedFields = fields.nestedFields(_model.fields),\n\t        _fields$nestedFields2 = _slicedToArray(_fields$nestedFields, 2),\n\t        _nestedFields = _fields$nestedFields2[0],\n\t        _subTypes = _fields$nestedFields2[1];\n\t\n\t    console.log(fields);\n\t\n\t    // Prepare the content of the query that will be sent to ES\n\t    // based on the kendo data structure\n\t    initOptions.transport.parameterMap = function (data) {\n\t      var sortParams = sort.prepareParams(data.sort, data.group, data.columns);\n\t\n\t      var esParams = {};\n\t      if (data.skip) {\n\t        esParams.from = data.skip;\n\t      }\n\t      if (data.take) {\n\t        esParams.size = data.take;\n\t      }\n\t\n\t      if (initOptions.aggregationsOnly) {\n\t        esParams.from = 0;\n\t        esParams.size = 0;\n\t      }\n\t\n\t      // Transform kendo sort params in a ES sort list\n\t      esParams.sort = sort.kendo2es(sortParams, _model.fields);\n\t\n\t      // Transform kendo filters into a ES query using a query_string request\n\t      esParams.query = {\n\t        filtered: {\n\t          filter: filters.kendo2es(data.filter || [], _model.fields, initOptions)\n\t        }\n\t      };\n\t\n\t      // Add a top level inner_hits definition for nested/parent/child docs\n\t      esParams['inner_hits'] = esUtils.innerHits(_nestedFields, _model.esMappingKey, _subTypes, esParams.sort, esParams.query.filtered.filter);\n\t\n\t      // Fetch only the required list of fields from ES\n\t      esParams._source = Object.keys(_model.fields).filter(function (k) {\n\t        return !_model.fields[k].esNestedPath && !_model.fields[k].esParentType && !_model.fields[k].esChildType;\n\t      }).map(function (k) {\n\t        return _model.fields[k].esName;\n\t      });\n\t\n\t      // Transform kendo aggregations into ES aggregations\n\t      esParams.aggs = aggregations.kendo2es(data.aggregate, _model.fields, _nestedFields, _model.esMappingKey, esParams.query.filtered.filter);\n\t\n\t      // Transform Kendo group instruction into an ES bucket aggregation\n\t      groups.kendo2es(esParams.aggs, data.group, _model.fields, _nestedFields, _model.esMappingKey, esParams.query.filtered.filter);\n\t\n\t      return JSON.stringify(esParams);\n\t    };\n\t\n\t    var schema = initOptions.schema;\n\t\n\t    // Parse the results from elasticsearch to return data items,\n\t    // total and aggregates for Kendo grid\n\t    schema.parse = function (response) {\n\t      var items = dataItems.fromHits(response.hits.hits, _model.fields);\n\t\n\t      // cheat. Root aggregations used as a pseudo buckets with doc_count = total number of results\n\t      // used to process missing counts\n\t      if (response.aggregations) {\n\t        response.aggregations.doc_count = response.hits.total;\n\t      }\n\t      var aggregates = aggregations.es2kendo(response.aggregations);\n\t      var grps = groups.es2kendo(items, response.aggregations, _model.fields, initOptions.aggregationsOnly);\n\t\n\t      return {\n\t        total: response.hits.total,\n\t        data: items,\n\t        aggregates: aggregates,\n\t        groups: grps\n\t      };\n\t    };\n\t\n\t    schema.aggregates = function (response) {\n\t      return response.aggregates;\n\t    };\n\t    schema.groups = function (response) {\n\t      return response.groups;\n\t    };\n\t\n\t    schema.data = schema.data || 'data';\n\t    schema.total = schema.total || 'total';\n\t    schema.model.id = schema.model.id || '_id';\n\t\n\t    initOptions.serverFiltering = true;\n\t    initOptions.serverSorting = true;\n\t    initOptions.serverPaging = true;\n\t    initOptions.serverAggregates = true;\n\t    initOptions.serverGrouping = true;\n\t\n\t    data.DataSource.fn.init.call(this, initOptions);\n\t  }\n\t});\n\t\n\tdata.ElasticSearchDataSource.kendoFieldsFromESMapping = fields.fromMapping;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar prepareParams = exports.prepareParams = _prepareParams;\n\t\n\t// Transform sort instruction into some object suitable for Elasticsearch\n\t// Also deal with sorting the different nesting levels\n\tfunction _kendo2es(sort, fields, nestedPath) {\n\t  return sort.filter(function (sortItem) {\n\t    var field = fields[sortItem.field];\n\t    if (!field) return false;\n\t    return field.esNestedPath === nestedPath || field.esParentType === nestedPath || field.esChildType === nestedPath;\n\t  }).map(function (sortItem) {\n\t    return _defineProperty({}, fields[sortItem.field].esFilterName, {\n\t      order: sortItem.dir,\n\t      // Always put items without the sorted key at the end\n\t      missing: '_last',\n\t      // Deal with sorting items by a property in nested documents\n\t      mode: sortItem.dir === 'asc' ? 'min' : 'max'\n\t    });\n\t  });\n\t};\n\t\n\t// Prepare sort parameters for easier transformation to ES later on\n\tfunction _prepareParams(sort) {\n\t  var groups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\n\t  // first fix the type of the param that can be object of group\n\t  // we always parse as an array\n\t  // http://docs.telerik.com/kendo-ui/api/javascript/data/datasource#configuration-sort\n\t  var sortArray = [];\n\t  if (sort && sort.constructor === Array) {\n\t    sortArray = sort;\n\t  } else {\n\t    if (sort) {\n\t      sortArray.push(sort);\n\t    }\n\t  }\n\t\n\t  // Sort instructions for the groups are first\n\t  var fullSort = [];\n\t  groups.forEach(function (group) {\n\t    var matchingSort = sortArray.filter(function (sortItem) {\n\t      return sortItem.field === group.field;\n\t    });\n\t    if (matchingSort.length) {\n\t      fullSort.push(matchingSort[0]);\n\t      sortArray.splice(sortArray.indexOf(matchingSort[0]), 1);\n\t    } else {\n\t      // Sort by default\n\t      fullSort.push({\n\t        field: group.field,\n\t        dir: group.dir || 'asc'\n\t      });\n\t    }\n\t  });\n\t\n\t  // Then original sort instructions are added\n\t  fullSort = fullSort.concat(sortArray);\n\t\n\t  return fullSort;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.es2kendo = exports.kendo2es = undefined;\n\t\n\tvar _aggregations = __webpack_require__(3);\n\t\n\tvar aggregations = _interopRequireWildcard(_aggregations);\n\t\n\tvar _dataItems = __webpack_require__(5);\n\t\n\tvar dataItems = _interopRequireWildcard(_dataItems);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar es2kendo = exports.es2kendo = _es2kendo;\n\t\n\t// Transform kendo groups declaration into ES bucket aggregations\n\tfunction _kendo2es(aggs, groups, fields, nestedFields, esMappingKey, filter) {\n\t  var previousLevelAggs = [aggs];\n\t  var previousLevelNestedPath = null;\n\t  groups.forEach(function (group) {\n\t    var field = fields[group.field];\n\t    var nextLevelAggs = _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter);\n\t\n\t    var aggs = {};\n\t    if (field.esNestedPath && field.esNestedPath.indexOf(previousLevelNestedPath) !== 0) {\n\t      aggs[field.esNestedPath + '_nested'] = aggs[field.esNestedPath + '_nested'] || {\n\t        nested: {\n\t          path: field.esFullNestedPath\n\t        },\n\t        aggs: {}\n\t      };\n\t      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_group'] = nextLevelAggs.group;\n\t      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_missing'] = nextLevelAggs.missing;\n\t    } else {\n\t      aggs[group.field + '_group'] = nextLevelAggs.group;\n\t      aggs[group.field + '_missing'] = nextLevelAggs.missing;\n\t    } // 3rd case for nested path that is not child of the previous group\n\t\n\t    previousLevelAggs.forEach(function (previousLevelAgg) {\n\t      Object.keys(aggs).forEach(function (aggKey) {\n\t        previousLevelAgg[aggKey] = aggs[aggKey];\n\t      });\n\t    });\n\t    previousLevelAggs = Object.keys(nextLevelAggs).map(function (aggKey) {\n\t      return nextLevelAggs[aggKey].aggregations;\n\t    });\n\t    previousLevelNestedPath = field.esNestedPath;\n\t  });\n\t}\n\t\n\tfunction _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter) {\n\t  var field = fields[group.field];\n\t  var groupAgg = {};\n\t  var missingAgg = {};\n\t\n\t  // Look for a aggregate defined on group field\n\t  // Used to customize the bucket aggregation for range, histograms, etc.\n\t  var fieldAggregate = void 0;\n\t  var groupAggregates = [];\n\t  (group.aggregates || []).forEach(function (aggregate) {\n\t    // We exclude strings that are not concerned by specific aggregations (only terms buckets)\n\t    // And cause bugs when counting cardinality on own group.\n\t    if (aggregate.field === group.field && field.type !== 'string') {\n\t      fieldAggregate = aggregate;\n\t    } else {\n\t      groupAggregates.push(aggregate);\n\t    }\n\t  });\n\t\n\t  if (fieldAggregate) {\n\t\n\t    // We support date histogramms if a 'interval' key is passed\n\t    // to the group definition\n\t    groupAgg[fieldAggregate.aggregate] = {\n\t      field: field.esAggName\n\t    };\n\t    if (fieldAggregate.interval) {\n\t      groupAgg[fieldAggregate.aggregate].interval = fieldAggregate.interval;\n\t    }\n\t  } else {\n\t\n\t    // Default is a term bucket aggregation\n\t    // if used on a not analyzed field or subfield\n\t    // it will create a group for each value of the field\n\t    groupAgg.terms = {\n\t      field: field.esAggName,\n\t      size: 0\n\t    };\n\t  }\n\t\n\t  missingAgg.missing = {\n\t    field: field.esAggName\n\t  };\n\t\n\t  var esGroupAggregates = aggregations.kendo2es(groupAggregates, fields, nestedFields, esMappingKey, filter, field.esNestedPath);\n\t  groupAgg.aggregations = esGroupAggregates;\n\t  missingAgg.aggregations = esGroupAggregates;\n\t\n\t  return {\n\t    group: groupAgg,\n\t    missing: missingAgg\n\t  };\n\t}\n\t\n\t// Extraction aggregations from ES query result that will be used to group\n\t// data items\n\tfunction _parseGroupAggregations(aggregations, missingNested) {\n\t  var groupAggregations = Object.keys(aggregations).filter(function (aggKey) {\n\t    return aggKey.substr(aggKey.length - 6) === '_group';\n\t  }).map(function (aggKey) {\n\t    var fieldKey = aggKey.substr(0, aggKey.length - 6);\n\t    if (missingNested) {\n\t      aggregations[fieldKey + '_missing'].doc_count += missingNested;\n\t    }\n\t    return {\n\t      group: aggregations[aggKey],\n\t      missing: aggregations[fieldKey + '_missing'],\n\t      fieldKey: fieldKey\n\t    };\n\t  });\n\t\n\t  // extract other group aggregations from nested aggregations\n\t  Object.keys(aggregations).filter(function (aggKey) {\n\t    return aggKey.substr(aggKey.length - 7) === '_nested';\n\t  }).forEach(function (aggKey) {\n\t    // 'missing' count on a nested group aggregation =\n\t    //      'document without nested objects' + 'nested objects with missing field'\n\t    // and 'document without nested objects' is equal to 'number of documents' - 'number of nested documents'\n\t    var missingNested = aggregations.doc_count - aggregations[aggKey].doc_count;\n\t    groupAggregations = groupAggregations.concat(_parseGroupAggregations(aggregations[aggKey], missingNested));\n\t  });\n\t\n\t  return groupAggregations;\n\t}\n\t\n\t// Transform ES bucket aggregations into kendo groups of data items\n\t// See doc here for format of groups:\n\t// http://docs.telerik.com/KENDO-UI/api/javascript/data/datasource#configuration-schema.groups\n\tfunction _es2kendo(items, aggregations, fields, aggregationsOnly) {\n\t  var allGroups = [];\n\t  if (aggregations) {\n\t    var groupAggregations = _parseGroupAggregations(aggregations);\n\t\n\t    // Find aggregations that are grouping aggregations (ie buckets in ES)\n\t    groupAggregations.forEach(function (groupAggregation) {\n\t      var groups = [];\n\t\n\t      var groupDefs = _esAgg2kendo(groupAggregation.group, groupAggregation.missing, groupAggregation.fieldKey);\n\t\n\t      if (!aggregationsOnly) {\n\t        // Then distribute the data items in the groups\n\t        groups = dataItems.fillInGroups(groupDefs, items, fields[groupAggregation.fieldKey]);\n\t      } else {\n\t        groups = groupDefs.keys.map(function (key) {\n\t          return groupDefs.map[key];\n\t        });\n\t      }\n\t\n\t      // Case when there is subgroups. Solve it recursively.\n\t      var hasSubgroups = false;\n\t      if (groupAggregation.group.buckets && groupAggregation.group.buckets[0]) {\n\t        Object.keys(groupAggregation.group.buckets[0]).forEach(function (bucketKey) {\n\t          if (bucketKey.substr(bucketKey.length - 6) === '_group' || bucketKey.substr(bucketKey.length - 7) === '_nested') {\n\t            hasSubgroups = true;\n\t          }\n\t        });\n\t      }\n\t      groups.forEach(function (group) {\n\t        if (hasSubgroups) {\n\t          group.hasSubgroups = true;\n\t          group.items = _es2kendo(group.items, group.bucket, fields, aggregationsOnly);\n\t        }\n\t        delete group.bucket;\n\t      });\n\t\n\t      allGroups = allGroups.concat(groups);\n\t    });\n\t  }\n\t\n\t  return allGroups;\n\t}\n\t\n\t// Transform a single bucket aggregation into kendo groups definitions\n\t// Does not fill up the data items\n\tfunction _esAgg2kendo(groupAggregation, missingAggregation, fieldKey) {\n\t  var groupsMap = {};\n\t  var groupKeys = [];\n\t\n\t  // Each bucket in ES aggregation result is a group\n\t  groupAggregation.buckets.forEach(function (bucket) {\n\t    var bucketKey = bucket.key_as_string || bucket.key;\n\t    groupKeys.push(bucketKey);\n\t    groupsMap[bucketKey] = {\n\t      field: fieldKey,\n\t      value: bucketKey,\n\t      hasSubgroups: false,\n\t      aggregates: aggregations.es2kendo(bucket),\n\t      items: [],\n\t      bucket: bucket\n\t    };\n\t    groupsMap[bucketKey].aggregates[fieldKey] = {\n\t      count: bucket.doc_count\n\t    };\n\t  });\n\t\n\t  // Special case for the missing value\n\t  groupsMap[''] = {\n\t    field: fieldKey,\n\t    value: '',\n\t    hasSubgroups: false,\n\t    aggregates: aggregations.es2kendo(missingAggregation),\n\t    items: [],\n\t    bucket: missingAggregation\n\t  };\n\t  groupsMap[''].aggregates[fieldKey] = {\n\t    count: missingAggregation.doc_count\n\t  };\n\t\n\t  return {\n\t    map: groupsMap,\n\t    keys: groupKeys\n\t  };\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.es2kendo = exports.kendo2es = undefined;\n\t\n\tvar _esUtils = __webpack_require__(4);\n\t\n\tvar esUtils = _interopRequireWildcard(_esUtils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar es2kendo = exports.es2kendo = _es2kendo;\n\t\n\tvar kendoToESAgg = {\n\t  count: 'cardinality',\n\t  min: 'min',\n\t  max: 'max',\n\t  sum: 'sum',\n\t  average: 'avg'\n\t};\n\t\n\t// Transform kendo aggregates into ES metric aggregations\n\tfunction _kendo2es() {\n\t  var aggregate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t  var fields = arguments[1];\n\t  var nestedFields = arguments[2];\n\t  var esMappingKey = arguments[3];\n\t  var filter = arguments[4];\n\t  var groupNestedPath = arguments[5];\n\t\n\t  var esAggs = {};\n\t\n\t  aggregate.forEach(function (aggItem) {\n\t    var field = fields[aggItem.field];\n\t    var nestedPath = field.esNestedPath;\n\t    var aggsWrapper = esAggs;\n\t    if (groupNestedPath !== nestedPath) {\n\t      var previousPathParts = [];\n\t      if (groupNestedPath && nestedPath.indexOf(groupNestedPath) !== 0) {\n\t        esAggs.group_reverse_nested = esAggs.group_reverse_nested || {\n\t          reverse_nested: {},\n\t          aggregations: {}\n\t        };\n\t        aggsWrapper = esAggs.group_reverse_nested.aggregations;\n\t      } else if (groupNestedPath) {\n\t        nestedPath = nestedPath.substr(groupNestedPath.length + 1, nestedPath.length);\n\t      }\n\t\n\t      nestedPath.split('.').forEach(function (nestedPathPart) {\n\t        previousPathParts.push(nestedPathPart);\n\t        var currentPath = groupNestedPath ? groupNestedPath + '.' + previousPathParts.join('.') : previousPathParts.join('.');\n\t        var fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n\t        var currentFields = nestedFields[currentPath];\n\t        if (!currentFields) return;\n\t        if (!aggsWrapper[currentPath]) {\n\t          aggsWrapper[currentPath + '_filter_nested'] = aggsWrapper[currentPath + '_filter_nested'] || {\n\t            nested: {\n\t              path: fullCurrentPath\n\t            },\n\t            aggregations: {}\n\t          };\n\t          aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] || {\n\t            filter: esUtils.innerHitsFilter(fullCurrentPath, null, filter),\n\t            aggregations: {}\n\t          };\n\t        }\n\t        aggsWrapper = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'].aggregations;\n\t      });\n\t    }\n\t\n\t    aggsWrapper[aggItem.field + '_' + aggItem.aggregate] = {};\n\t    aggsWrapper[aggItem.field + '_' + aggItem.aggregate][kendoToESAgg[aggItem.aggregate]] = {\n\t      field: field.esAggName\n\t    };\n\t  });\n\t\n\t  return esAggs;\n\t}\n\t\n\t// Transform aggregation results from a ES query to kendo aggregates\n\tfunction _es2kendo() {\n\t  var aggregations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t  var aggregates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  Object.keys(aggregations).forEach(function (aggKey) {\n\t    if (!aggregations[aggKey]) return;\n\t    ['count', 'min', 'max', 'average', 'sum'].forEach(function (aggType) {\n\t      var suffixLength = aggType.length + 1;\n\t      if (aggKey.substr(aggKey.length - suffixLength) === '_' + aggType) {\n\t        var fieldKey = aggKey.substr(0, aggKey.length - suffixLength);\n\t        aggregates[fieldKey] = aggregates[fieldKey] || {};\n\t        aggregates[fieldKey][aggType] = aggregations[aggKey].value;\n\t      }\n\t    });\n\t\n\t    if (aggKey.substr(aggKey.length - 7) === '_nested' || aggKey.substr(aggKey.length - 7) === '_filter') {\n\t      // recursivity on intermediate levels\n\t      _es2kendo(aggregations[aggKey], aggregates);\n\t    }\n\t  });\n\t  return aggregates;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t// Some function that work on ES queries to deal with nested levels and other\n\t// difficulties\n\t\n\tvar innerHits = exports.innerHits = _innerHits;\n\tvar innerHitsFilter = exports.innerHitsFilter = _innerHitsFilter;\n\t\n\t// Get a root inner_hits definition to fetch all nested/parent/child docs\n\tfunction _innerHits(nestedFields, esMappingKey, subTypes, sort, filter) {\n\t  var innerHits = {};\n\t  Object.keys(nestedFields).forEach(function (nestedPath) {\n\t    var previousLevelInnerHits = innerHits;\n\t    var previousPathParts = [];\n\t    nestedPath.split('.').forEach(function (nestedPathPart) {\n\t      previousPathParts.push(nestedPathPart);\n\t      var currentPath = previousPathParts.join('.');\n\t      var fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n\t      var currentFields = nestedFields[currentPath];\n\t      if (!currentFields) {\n\t        return;\n\t      }\n\t      if (!previousLevelInnerHits[currentPath]) {\n\t        previousLevelInnerHits[currentPath] = {\n\t          path: _defineProperty({}, fullCurrentPath, {\n\t            _source: currentFields,\n\t            size: 10000,\n\t            sort: sort,\n\t            query: {\n\t              filtered: {\n\t                filter: _innerHitsFilter(fullCurrentPath, null, filter)\n\t              }\n\t            }\n\t          })\n\t        };\n\t      }\n\t      if (currentPath !== nestedPath) {\n\t        previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits = previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits || {};\n\t        previousLevelInnerHits = previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits;\n\t      }\n\t    });\n\t  });\n\t\n\t  Object.keys(subTypes).forEach(function (subType) {\n\t    var currentFields = subTypes[subType];\n\t    innerHits[subType] = {\n\t      type: _defineProperty({}, subType, {\n\t        _source: currentFields,\n\t        size: 10000,\n\t        sort: sort,\n\t        query: {\n\t          filtered: {\n\t            filter: _innerHitsFilter(null, subType, filter)\n\t          }\n\t        }\n\t      })\n\t    };\n\t  });\n\t  return innerHits;\n\t}\n\t\n\tfunction _manageBooleanFilter(nestedPath, subType, booleanFilter) {\n\t  return booleanFilter.filter(function (childFilter) {\n\t    return childFilter.bool && childFilter.bool.must || childFilter.bool && childFilter.bool.should || childFilter.nested && childFilter.nested.path === nestedPath || childFilter.not && childFilter.not.nested && childFilter.not.nested.path === nestedPath || childFilter.has_child && childFilter.has_child.type === subType || childFilter.not && childFilter.not.has_child && childFilter.not.has_child.type === subType || childFilter.has_parent && childFilter.has_parent.type === subType || childFilter.not && childFilter.not.has_parent && childFilter.not.has_parent.type === subType;\n\t  }).map(function (childFilter) {\n\t    if (childFilter.nested) {\n\t      return childFilter.nested.filter;\n\t    } else if (childFilter.not && childFilter.not.nested) {\n\t      return {\n\t        not: childFilter.not.nested.filter\n\t      };\n\t    } else if (childFilter.has_child) {\n\t      return childFilter.has_child.filter;\n\t    } else if (childFilter.not && childFilter.not.has_child) {\n\t      return {\n\t        not: childFilter.not.has_child.filter\n\t      };\n\t    } else if (childFilter.has_parent) {\n\t      return childFilter.has_parent.filter;\n\t    } else if (childFilter.not && childFilter.not.has_parent) {\n\t      return {\n\t        not: childFilter.not.has_parent.filter\n\t      };\n\t    } else {\n\t      return _innerHitsFilter(nestedPath, childFilter);\n\t    }\n\t  });\n\t}\n\t\n\t// Traverse the filter to keep only the parts that concern\n\t// a nesting path\n\tfunction _innerHitsFilter(nestedPath, subType, filter) {\n\t  filter = $.extend(true, {}, filter);\n\t  if (filter.bool && filter.bool.must) {\n\t    filter.bool.must = _manageBooleanFilter(nestedPath, subType, filter.bool.must);\n\t  }\n\t\n\t  if (filter.bool && filter.bool.should) {\n\t    filter.bool.should = _manageBooleanFilter(nestedPath, subType, filter.bool.should);\n\t  }\n\t\n\t  return filter;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar fillInGroups = exports.fillInGroups = _fillInGroups;\n\tvar fromHits = exports.fromHits = _fromHits;\n\t\n\t// distribute data items in groups based on a field value\n\tfunction _fillInGroups(groupDefs, dataItems, field) {\n\t  var groups = [];\n\t  dataItems.forEach(function (dataItem) {\n\t    var group = groupDefs.map[dataItem[field.key] || ''];\n\t\n\t    // If no exact match, then we may be in some range aggregation ?\n\t    if (!group) {\n\t      var fieldValue = field.type === 'date' ? new Date(dataItem[field.key]) : dataItem[field.key];\n\t\n\t      for (var i = 0; i < groupDefs.keys.length; i++) {\n\t        var groupDefValue = field.type === 'date' ? new Date(groupDefs.keys[i]) : groupDefs.keys[i];\n\t        if (fieldValue >= groupDefValue) {\n\t          var groupDefNextValue = groupDefs.keys[i + 1] && (field.type === 'date' ? new Date(groupDefs.keys[i + 1]) : groupDefs.keys[i + 1]);\n\t          if (!groupDefNextValue || fieldValue < groupDefNextValue) {\n\t            group = groupDefs.map[groupDefs.keys[i]];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (!group) {\n\t      throw new Error('No group found, val: ' + dataItem[field.key] + ' field: ' + field.key);\n\t    }\n\t    group.items.push(dataItem);\n\t    if (group.items.length === 1) {\n\t      groups.push(group);\n\t    }\n\t  });\n\t  return groups;\n\t}\n\t\n\t// Mimic fetching values from _source as the 'fields' functionality\n\t// would have done it.\n\t// We do not use the native 'fields' due to this bug:\n\t// https://github.com/elastic/elasticsearch/issues/14475\n\tfunction _getValuesFromSource(source, pathParts) {\n\t  var values = [];\n\t  var value = source[pathParts[0]];\n\t  if (value === undefined) {\n\t    return [];\n\t  }\n\t\n\t  if (pathParts.length > 1) {\n\t\n\t    // recursivity is not over, there remain some path parts\n\t    if ($.isArray(value)) {\n\t      value.forEach(function (valueItem) {\n\t        values = values.concat(_getValuesFromSource(valueItem, pathParts.slice(1)));\n\t      });\n\t    } else {\n\t      values = _getValuesFromSource(value, pathParts.slice(1));\n\t    }\n\t  } else {\n\t\n\t    // recursivity, we should be in a leaf value\n\t    if ($.isArray(value)) {\n\t      values = value;\n\t    } else {\n\t      values = [value];\n\t    }\n\t  }\n\t  return values;\n\t}\n\t\n\t// Transform hits from the ES query in to data items for kendo grid\n\t// The difficulty is that hits can contain inner hits and that some\n\t// fields can be multi-valued\n\tfunction _fromHits(hits, fields, innerPath) {\n\t\n\t  var dataItems = [];\n\t  hits.forEach(function (hit) {\n\t    var hitSource = hit._source || {};\n\t    var dataItem = {};\n\t\n\t    dataItem.id = [hit._id];\n\t    Object.keys(fields).filter(function (fieldKey) {\n\t      var field = fields[fieldKey];\n\t\n\t      // Keep only the fields that are part of this nested/parent/child\n\t      if (innerPath === undefined) {\n\t        return !(field.esNestedPath || field.esChildType || field.esParentType);\n\t      } else {\n\t        return field.esNestedPath === innerPath || field.esChildType === innerPath || field.esParentType === innerPath;\n\t      }\n\t    }).forEach(function (fieldKey) {\n\t      var field = fields[fieldKey];\n\t      var values = _getValuesFromSource(hitSource, field.esNameSplit);\n\t\n\t      // special case field that is a date deep down by displayed as a number\n\t      if (field.duration) {\n\t        if (!moment) {\n\t          throw new Error('Working on durations requires to load momentjs library');\n\t        }\n\t      }\n\t\n\t      if (field.duration === 'beforeToday') {\n\t        values = values.map(function (value) {\n\t          return moment().startOf('day').diff(moment(value).startOf('day'), 'days');\n\t        });\n\t      }\n\t\n\t      if (field.duration === 'afterToday') {\n\t        values = values.map(function (value) {\n\t          return moment(value).startOf('day').diff(moment().startOf('day'), 'days');\n\t        });\n\t      }\n\t\n\t      if (values) {\n\t        if (field.esMultiSplit) {\n\t          if (values && values.length) {\n\t            dataItem[fieldKey] = values;\n\t          } else {\n\t            dataItem[fieldKey] = [null];\n\t          }\n\t        } else {\n\t          dataItem[fieldKey] = values.join(field.esMultiSeparator || '\\n');\n\t        }\n\t      }\n\t    });\n\t\n\t    // Multiply and fill items based on nesting levels\n\t    var splittedItems = [dataItem];\n\t    Object.keys(hit.inner_hits || {}).forEach(function (innerHitKey) {\n\t      var nestedItems = _fromHits(hit.inner_hits[innerHitKey].hits.hits, fields, innerHitKey);\n\t      var newSplittedDataItems = [];\n\t      splittedItems.forEach(function (splittedItem) {\n\t        if (nestedItems.length) {\n\t          nestedItems.forEach(function (nestedItem) {\n\t            var mergedItem = {};\n\t            Object.keys(nestedItem).forEach(function (key) {\n\t              mergedItem[key] = nestedItem[key];\n\t            });\n\t            Object.keys(splittedItem).forEach(function (key) {\n\t              mergedItem[key] = splittedItem[key];\n\t            });\n\t            newSplittedDataItems.push(mergedItem);\n\t          });\n\t        } else {\n\t          newSplittedDataItems.push(splittedItem);\n\t        }\n\t      });\n\t      splittedItems = newSplittedDataItems;\n\t    });\n\t\n\t    dataItems = dataItems.concat(splittedItems);\n\t  });\n\t  return _splitMultiValues(dataItems);\n\t}\n\t\n\t// Split lines of data items based on their optionally multipl items\n\t// Example: [{a:[1,2],b:[3]}] -> [{a:1,b:3},{a:2,b:3}]\n\tfunction _splitMultiValues(items) {\n\t  var results = [];\n\t\n\t  // Iterates on items in the array and multiply based on multiple values\n\t  items.forEach(function (item) {\n\t    var itemResults = [{}];\n\t\n\t    // Iterate on properties of item\n\t    Object.keys(item).forEach(function (k) {\n\t      var partialItemResults = [];\n\t\n\t      // Iterate on the multiple values of this property\n\t      if (item[k] && item[k].constructor === Array) {\n\t        item[k].forEach(function (val) {\n\t          itemResults.forEach(function (result) {\n\t\n\t            // Clone the result to create variants with the different values of current key\n\t            var newResult = {};\n\t            Object.keys(result).forEach(function (k2) {\n\t              return newResult[k2] = result[k2];\n\t            });\n\t            newResult[k] = val;\n\t            partialItemResults.push(newResult);\n\t          });\n\t        });\n\t      } else {\n\t        itemResults.forEach(function (result) {\n\t          result[k] = item[k];\n\t          partialItemResults.push(result);\n\t        });\n\t      }\n\t      itemResults = partialItemResults;\n\t    });\n\t\n\t    results = results.concat(itemResults);\n\t  });\n\t  return results;\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\t\n\t// Transform a tree of kendo filters into a tree of ElasticSearch filters\n\tfunction _kendo2es(kendoFilters, fields, initOptions) {\n\t  var filters = void 0;\n\t\n\t  // logicalConnective can be \"and\" or \"or\"\n\t  var logicalConnective = 'and';\n\t\n\t  if (kendoFilters.operator) {\n\t    filters = [kendoFilters];\n\t  } else if (kendoFilters.logic) {\n\t    logicalConnective = kendoFilters.logic;\n\t    filters = kendoFilters.filters || [];\n\t  } else if (kendoFilters.constructor === Array) {\n\t    filters = kendoFilters;\n\t  } else {\n\t    throw new Error('Unsupported filter object: ' + kendoFilters);\n\t  }\n\t\n\t  var esFilters = [];\n\t  var esNestedFilters = {};\n\t\n\t  filters.forEach(function (filter) {\n\t    if (filter.logic) {\n\t      esFilters.push(_kendo2es(filter, fields));\n\t    } else {\n\t      var field = fields[filter.field];\n\t      if (!field) {\n\t        throw new Error('Unknown field in filter: ' + filter.field);\n\t      }\n\t      var esFilter = void 0;\n\t      try {\n\t        esFilter = {\n\t          query: {\n\t            query_string: {\n\t              query: _filterParam(filter, fields, initOptions),\n\t              // support uppercase/lowercase and accents\n\t              analyze_wildcard: true\n\t            }\n\t          }\n\t        };\n\t      } catch (error) {\n\t        if (error.message === 'missing filter is not supported on nested fields') {\n\t          esFilter = {\n\t            not: {\n\t              nested: {\n\t                path: field.esNestedPath,\n\t                filter: {\n\t                  exists: {\n\t                    field: field.esSearchName\n\t                  }\n\t                }\n\t              }\n\t            }\n\t          };\n\t        } else {\n\t          throw error;\n\t        }\n\t      };\n\t\n\t      if (field.esNestedPath && !esFilter.not) {\n\t        var esNestedFilter = esNestedFilters[field.esNestedPath] || {\n\t          nested: {\n\t            path: field.esFullNestedPath,\n\t            filter: {\n\t              bool: {}\n\t            }\n\t          }\n\t        };\n\t\n\t        switch (logicalConnective) {\n\t          case 'and':\n\t            {\n\t              esNestedFilter.nested.filter.bool.must = esNestedFilter.nested.filter.bool.must || [];\n\t              esNestedFilter.nested.filter.bool.must.push(esFilter);\n\t              break;\n\t            }\n\t\n\t          case 'or':\n\t            {\n\t              esNestedFilter.nested.filter.bool.should = esNestedFilter.nested.filter.bool.should || [];\n\t              esNestedFilter.nested.filter.bool.should.push(esFilter);\n\t              break;\n\t            }\n\t        }\n\t\n\t        if (!esNestedFilters[field.esNestedPath]) {\n\t          esFilter = esNestedFilters[field.esNestedPath] = esNestedFilter;\n\t        } else {\n\t          esFilter = null;\n\t        }\n\t      } else if (field.esParentType) {\n\t        esFilter = {\n\t          has_parent: {\n\t            type: field.esParentType,\n\t            filter: esFilter\n\t          }\n\t        };\n\t      } else if (field.esChildType) {\n\t        esFilter = {\n\t          has_child: {\n\t            type: field.esChildType,\n\t            filter: esFilter\n\t          }\n\t        };\n\t      }\n\t\n\t      if (esFilter) {\n\t        esFilters.push(esFilter);\n\t      }\n\t    }\n\t  });\n\t\n\t  var result = {\n\t    bool: {}\n\t  };\n\t  switch (logicalConnective) {\n\t    case 'and':\n\t      {\n\t        result.bool.must = esFilters;\n\t        break;\n\t      }\n\t\n\t    case 'or':\n\t      {\n\t        result.bool.should = esFilters;\n\t        break;\n\t      }\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\t// Transform a single kendo filter in a string\n\t// that can be used to compose a ES query_string query\n\tfunction _filterParam(kendoFilter, fields, initOptions) {\n\t\n\t  // Boolean filter seems to forget the operator sometimes\n\t  kendoFilter.operator = kendoFilter.operator || 'eq';\n\t\n\t  // Use the filter field name except for contains\n\t  // that should use classical search instead of regexp\n\t  var field = fields[kendoFilter.field];\n\t\n\t  // special case field that is a date deep down by displayed as a number\n\t  if (field.duration) {\n\t    if (!moment) {\n\t      throw new Error('Working on durations requires to load momentjs library');\n\t    }\n\t  }\n\t\n\t  if (field.duration === 'beforeToday') {\n\t    kendoFilter.value = moment().startOf('day').subtract(kendoFilter.value, 'days').format();\n\t    if (kendoFilter.operator === 'lt') kendoFilter.operator = 'gt';else if (kendoFilter.operator === 'lte') kendoFilter.operator = 'gte';else if (kendoFilter.operator === 'gt') kendoFilter.operator = 'lt';else if (kendoFilter.operator === 'gte') kendoFilter.operator = 'lte';\n\t  }\n\t\n\t  if (field.duration === 'afterToday') {\n\t    kendoFilter.value = moment().startOf('day').add(kendoFilter.value, 'days').format();\n\t  }\n\t\n\t  var fieldName = void 0;\n\t  if (kendoFilter.operator === 'search') {\n\t    fieldName = field.esSearchName;\n\t  } else {\n\t    fieldName = field.esFilterName;\n\t  }\n\t\n\t  var fieldEscaped = _asESParameter(fieldName);\n\t  var valueEscaped = _asESParameter(kendoFilter.value, kendoFilter.operator);\n\t\n\t  var simpleBinaryOperators = {\n\t    eq: '',\n\t    search: '',\n\t    lt: '<',\n\t    lte: '<=',\n\t    gt: '>',\n\t    gte: '>='\n\t  };\n\t\n\t  if (simpleBinaryOperators[kendoFilter.operator] !== void 0) {\n\t    var esOperator = simpleBinaryOperators[kendoFilter.operator];\n\t    // Optional special condition, when comparing against bool false values\n\t    // we treat also the missing property condition, like this, false === missing too\n\t    // Event if this is not true, normally is the desired effect\n\t    if (initOptions && initOptions.missingBooleanAsFalse === true && kendoFilter.value === false) {\n\t      return fieldEscaped + ':' + esOperator + valueEscaped + ' OR _missing_:' + fieldEscaped;\n\t    } else {\n\t      return fieldEscaped + ':' + esOperator + valueEscaped;\n\t    }\n\t  } else {\n\t    var expression = void 0;\n\t    switch (kendoFilter.operator) {\n\t      case 'neq':\n\t        return 'NOT (' + fieldEscaped + ':' + valueEscaped + ')';\n\t      case 'contains':\n\t        return '(' + fieldEscaped + ':*' + valueEscaped + '*)';\n\t      case 'doesnotcontain':\n\t        return 'NOT (' + fieldEscaped + ':*' + valueEscaped + '*)';\n\t      case 'startswith':\n\t        return fieldEscaped + ':' + valueEscaped + '*';\n\t      case 'endswith':\n\t        return fieldEscaped + ':*' + valueEscaped;\n\t      case 'missing':\n\t        if (field.esNestedPath || field.esParentType || field.esChildType) {\n\t          // missing in a nested document should be implemented as a \"not nested exists\"\n\t          // but this is not really doable when mixing with other filters\n\t          // see https://github.com/elastic/elasticsearch/issues/3495\n\t          throw new Error('missing filter is not supported on nested fields');\n\t        }\n\t        expression = '_missing_:' + fieldEscaped;\n\t        if (field.type === 'string') {\n\t          expression += ' OR (' + fieldEscaped + ':\"\")';\n\t        }\n\t        return expression;\n\t      case 'exists':\n\t        expression = '_exists_:' + fieldEscaped;\n\t        if (field.type === 'string') {\n\t          expression += ' AND NOT(' + fieldEscaped + ':\"\")';\n\t        }\n\t        return expression;\n\t      default:\n\t        throw new Error('Unsupported Kendo filter operator: ' + kendoFilter.operator);\n\t    }\n\t  }\n\t}\n\t\n\t// Escape values so that they are suitable as an elasticsearch query_string query parameter\n\tvar escapeValueRegexp = /[+\\-&|!()\\{}\\[\\]^:\"~*?:\\/ ]/g;\n\tvar escapeSearchValueRegexp = /[+\\-&|!()\\{}\\[\\]^:~:\\/]/g;\n\t\n\tfunction _asESParameter(value, operator) {\n\t  if (value.constructor === Date) {\n\t    value = value.toISOString();\n\t  } else if (typeof value === 'boolean' || typeof value === 'number') {\n\t    value = '' + value;\n\t  }\n\t\n\t  // For the special 'search' operator we allow some wildcard and other characters\n\t  if (operator === 'search') {\n\t    value = value.replace('\\\\', '\\\\\\\\');\n\t    if ((value.match(/\"/g) || []).length % 2 === 1) {\n\t      value = value.replace(/\"/g, '\\\\\"');\n\t    }\n\t    value = value.replace(escapeSearchValueRegexp, '\\\\$&');\n\t    return value;\n\t  }\n\t  return value.replace('\\\\', '\\\\\\\\').replace(escapeValueRegexp, '\\\\$&');\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar fromMapping = exports.fromMapping = _fromMapping;\n\tvar fill = exports.fill = _fill;\n\tvar nestedFields = exports.nestedFields = _nestedFields;\n\t\n\t// Transform a mapping definition from ElasticSearch into a kendo fields map\n\t// This utility function is exposed as it can be interesting to use it before instantiating\n\t// the actual datasource\n\t// @param mapping - An elasticsearch mapping\n\tfunction _fromMapping(mapping, model) {\n\t  var fields = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t  var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t  var esPrefix = arguments[4];\n\t  var nestedPath = arguments[5];\n\t\n\t  Object.keys(mapping.properties || {}).forEach(function (propertyKey) {\n\t    var property = mapping.properties[propertyKey];\n\t    var curedPropertyKey = asKendoPropertyKey(propertyKey);\n\t    var prefixedName = prefix ? prefix + '_' + curedPropertyKey : curedPropertyKey;\n\t    var esName = esPrefix ? esPrefix + '.' + propertyKey : propertyKey;\n\t\n\t    if (property.type === 'nested') {\n\t      // Case where the property is a nested object\n\t      var subNestedPath = nestedPath ? nestedPath + '.' + esName : esName;\n\t      _fromMapping(property, model, fields, prefixedName, '', subNestedPath);\n\t    } else if (property.properties) {\n\t      // Case where the property is a non nested object with properties\n\t      _fromMapping(property, model, fields, prefixedName, esName, nestedPath);\n\t    } else if (property.type === 'object') {\n\t      // Case where the property is a non nested object with zero subproperties. do nothing.\n\t    } else {\n\t      // Finally case of a leaf property\n\t      var field = fields[prefixedName] = fields[prefixedName] || {};\n\t\n\t      // if the field was already defined with a nested path,\n\t      // then we are in the case of field both nested and included in parent\n\t      // then we should not consider it as a real leaf property\n\t      if (!field.esNestedPath) {\n\t        field.type = field.type || property.type;\n\t\n\t        // ES supports a variety of numeric types. In JSON and kendo it is simply 'number'.\n\t        if (['float', 'double', 'integer', 'long', 'short', 'byte'].indexOf(field.type) !== -1) {\n\t          field.type = 'number';\n\t        }\n\t\n\t        // Default is splitting data lines except for string fields\n\t        if (field.type !== 'string') {\n\t          field.esMultiSplit = true;\n\t        }\n\t\n\t        if (nestedPath) {\n\t          field.esNestedPath = nestedPath;\n\t        }\n\t        field.esName = esName;\n\t\n\t        // When the field is not analyzed, the default string subfields should not be applied.\n\t        if (property.index === 'not_analyzed') {\n\t          field.esSearchSubField = null;\n\t          field.esFilterSubField = null;\n\t          field.esAggSubField = null;\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  _fill(fields, model);\n\t\n\t  return fields;\n\t};\n\t\n\t// Associate Kendo field names to ElasticSearch field names.\n\t// We have to allow ElasticSearch field names to be different\n\t// because ES likes an \"@\" and/or dots in field names while Kendo fails on that.\n\t// Filtering and aggregating can be based on a a different field if esFilterName\n\t// or esAggName are defined or on a subfield if esFilterSubField or esAggSubField are defined.\n\t// Typical use case is the main field is analyzed, but it has a subfield that is not\n\t// (or only with a minimal analyzer)\n\tfunction _fill(fields) {\n\t  var model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  for (var k in fields) {\n\t    if (fields.hasOwnProperty(k)) {\n\t      var field = fields[k];\n\t      field.key = k;\n\t      field.esName = field.esName || k;\n\t      field.esNameSplit = field.esName.split('.');\n\t      if (field.esNestedPath) {\n\t        field.esFullNestedPath = field.esNestedPath;\n\t        if (model.esMappingKey) {\n\t          field.esFullNestedPath = model.esMappingKey + '.' + field.esFullNestedPath;\n\t        }\n\t      }\n\t      if (!field.esSearchName) {\n\t        field.esSearchName = field.esName;\n\t        if (field.hasOwnProperty('esSearchSubField')) {\n\t          if (field.esSearchSubField) {\n\t            field.esSearchName += '.' + field.esSearchSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.search) {\n\t          field.esSearchName += '.' + model.esStringSubFields.search;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esSearchName = field.esNestedPath + '.' + field.esSearchName;\n\t        }\n\t      }\n\t      if (!field.esFilterName) {\n\t        field.esFilterName = field.esName;\n\t        if (field.hasOwnProperty('esFilterSubField')) {\n\t          if (field.esFilterSubField) {\n\t            field.esFilterName += '.' + field.esFilterSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.filter) {\n\t          field.esFilterName += '.' + model.esStringSubFields.filter;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esFilterName = field.esNestedPath + '.' + field.esFilterName;\n\t        }\n\t      }\n\t      if (!field.esAggName) {\n\t        field.esAggName = field.esName;\n\t        if (field.hasOwnProperty('esAggSubField')) {\n\t          if (field.esAggSubField) {\n\t            field.esAggName += '.' + field.esAggSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.agg) {\n\t          field.esAggName += '.' + model.esStringSubFields.agg;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esAggName = field.esFullNestedPath + '.' + field.esAggName;\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// Get a property key and transform it in a suitable key for kendo\n\t// the constraint is that kendo needs a key suitable for javascript object's dot notation\n\t// i.e a valid js identifier with alphanumeric chars + '_' and '$'\n\tfunction asKendoPropertyKey(value) {\n\t  return value.replace(/[^a-zA-z0-9_$]/g, '_');\n\t}\n\t\n\t// Get sets of nesting levels and matching groups of fields\n\tfunction _nestedFields(fields) {\n\t  var _result = {};\n\t  var _subTypes = {};\n\t  Object.keys(fields).forEach(function (fieldKey) {\n\t    var field = fields[fieldKey];\n\t    if (field.esNestedPath) {\n\t      _result[field.esNestedPath] = _result[field.esNestedPath] || [];\n\t      _result[field.esNestedPath].push(field.esName);\n\t    }\n\t    if (field.esParentType) {\n\t      _subTypes[field.esParentType] = _subTypes[field.esParentType] || [];\n\t      _subTypes[field.esParentType].push(field.esName);\n\t    }\n\t    if (field.esChildType) {\n\t      _subTypes[field.esChildType] = _subTypes[field.esChildType] || [];\n\t      _subTypes[field.esChildType].push(field.esName);\n\t    }\n\t  });\n\t\n\t  return [_result, _subTypes];\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** kendo-elasticsearch.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0d480a7861c0c67886de\n **/","/**\n * A Kendo DataSource that gets its data from ElasticSearch.\n *\n * Read-only, supports paging, filtering, sorting, grouping and aggregations.\n */\n\nimport * as sort from './sort';\nimport * as groups from './groups';\nimport * as aggregations from './aggregations';\nimport * as filters from './filters';\nimport * as esUtils from './es-utils';\nimport * as dataItems from './data-items';\nimport * as fields from './fields';\n\nconst data = kendo.data;\n\ndata.ElasticSearchDataSource = data.DataSource.extend({\n  init(initOptions) {\n    if (!initOptions) {\n      throw new Error('Options are required to use ElasticSearchDataSource');\n    }\n\n    // Prepare the transport to query ES\n    // The only required parameter is transport.read.url\n    if (initOptions.transport && initOptions.transport.read && initOptions.transport.read.url) {\n      const readTransport = initOptions.transport.read;\n      readTransport.dataType = readTransport.dataType || 'json';\n      readTransport.method = readTransport.method || 'POST';\n      readTransport.contentType = readTransport.contentType || 'application/json';\n    } else {\n      throw new Error('transport.read.url must be set to use ElasticSearchDataSource');\n    }\n\n    const _model = initOptions.schema && initOptions.schema.model;\n    if (!_model) {\n      throw new Error('transport.schema.model must be set to use ElasticSearchDataSource');\n    }\n    if (_model.esMapping) {\n      _model.fields = _model.fields || {};\n      data.ElasticSearchDataSource.kendoFieldsFromESMapping(\n        _model.esMapping, _model, _model.fields);\n    } else {\n      if (!_model.fields) {\n        throw new Error('transport.schema.model.fields/esMapping must be set');\n      }\n      fields.fill(_model.fields, _model);\n    }\n\n    // Get sets of nesting levels\n    const [_nestedFields, _subTypes] = fields.nestedFields(_model.fields);\n    console.log(fields);\n\n    // Prepare the content of the query that will be sent to ES\n    // based on the kendo data structure\n    initOptions.transport.parameterMap = function (data) {\n      const sortParams = sort.prepareParams(data.sort, data.group, data.columns);\n\n      const esParams = {};\n      if (data.skip) {\n        esParams.from = data.skip;\n      }\n      if (data.take) {\n        esParams.size = data.take;\n      }\n\n      if (initOptions.aggregationsOnly) {\n        esParams.from = 0;\n        esParams.size = 0;\n      }\n\n      // Transform kendo sort params in a ES sort list\n      esParams.sort = sort.kendo2es(sortParams, _model.fields);\n\n      // Transform kendo filters into a ES query using a query_string request\n      esParams.query = {\n        filtered: {\n          filter: filters.kendo2es(data.filter || [], _model.fields, initOptions)\n        }\n      };\n\n      // Add a top level inner_hits definition for nested/parent/child docs\n      esParams['inner_hits'] = esUtils.innerHits(\n        _nestedFields,\n        _model.esMappingKey,\n        _subTypes,\n        esParams.sort,\n        esParams.query.filtered.filter\n      );\n\n      // Fetch only the required list of fields from ES\n      esParams._source = Object.keys(_model.fields)\n        .filter(k =>\n          !_model.fields[k].esNestedPath &&\n          !_model.fields[k].esParentType &&\n          !_model.fields[k].esChildType)\n        .map(k => _model.fields[k].esName);\n\n      // Transform kendo aggregations into ES aggregations\n      esParams.aggs = aggregations.kendo2es(\n        data.aggregate,\n        _model.fields,\n        _nestedFields,\n        _model.esMappingKey,\n        esParams.query.filtered.filter\n      );\n\n      // Transform Kendo group instruction into an ES bucket aggregation\n      groups.kendo2es(\n        esParams.aggs,\n        data.group,\n        _model.fields,\n        _nestedFields,\n        _model.esMappingKey,\n        esParams.query.filtered.filter\n      );\n\n      return JSON.stringify(esParams);\n    };\n\n    const schema = initOptions.schema;\n\n    // Parse the results from elasticsearch to return data items,\n    // total and aggregates for Kendo grid\n    schema.parse = function (response) {\n      const items = dataItems.fromHits(response.hits.hits, _model.fields);\n\n      // cheat. Root aggregations used as a pseudo buckets with doc_count = total number of results\n      // used to process missing counts\n      if (response.aggregations) {\n        response.aggregations.doc_count = response.hits.total;\n      }\n      const aggregates = aggregations.es2kendo(response.aggregations);\n      const grps = groups.es2kendo(items, response.aggregations, _model.fields, initOptions.aggregationsOnly);\n\n      return {\n        total: response.hits.total,\n        data: items,\n        aggregates: aggregates,\n        groups: grps\n      };\n    };\n\n    schema.aggregates = response => response.aggregates;\n    schema.groups = response => response.groups;\n\n    schema.data = schema.data || 'data';\n    schema.total = schema.total || 'total';\n    schema.model.id = schema.model.id || '_id';\n\n    initOptions.serverFiltering = true;\n    initOptions.serverSorting = true;\n    initOptions.serverPaging = true;\n    initOptions.serverAggregates = true;\n    initOptions.serverGrouping = true;\n\n    data.DataSource.fn.init.call(this, initOptions);\n  }\n});\n\ndata.ElasticSearchDataSource.kendoFieldsFromESMapping = fields.fromMapping;\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/kendo-elasticsearch.js\n **/","export const kendo2es = _kendo2es;\nexport const prepareParams = _prepareParams;\n\n// Transform sort instruction into some object suitable for Elasticsearch\n// Also deal with sorting the different nesting levels\nfunction _kendo2es(sort, fields, nestedPath) {\n  return sort.filter(sortItem => {\n    const field = fields[sortItem.field];\n    if (!field) return false;\n    return field.esNestedPath === nestedPath ||\n      field.esParentType === nestedPath ||\n      field.esChildType === nestedPath;\n  }).map(sortItem => {\n    return {\n      [fields[sortItem.field].esFilterName]: {\n        order: sortItem.dir,\n        // Always put items without the sorted key at the end\n        missing: '_last',\n        // Deal with sorting items by a property in nested documents\n        mode: sortItem.dir === 'asc' ? 'min' : 'max'\n      }\n    };\n  });\n};\n\n// Prepare sort parameters for easier transformation to ES later on\nfunction _prepareParams(sort, groups = []) {\n  // first fix the type of the param that can be object of group\n  // we always parse as an array\n  // http://docs.telerik.com/kendo-ui/api/javascript/data/datasource#configuration-sort\n  let sortArray = [];\n  if (sort && sort.constructor === Array) {\n    sortArray = sort;\n  } else {\n    if (sort) {\n      sortArray.push(sort);\n    }\n  }\n\n  // Sort instructions for the groups are first\n  let fullSort = [];\n  groups.forEach(group => {\n    const matchingSort = sortArray.filter(function (sortItem) {\n      return sortItem.field === group.field;\n    });\n    if (matchingSort.length) {\n      fullSort.push(matchingSort[0]);\n      sortArray.splice(sortArray.indexOf(matchingSort[0]), 1);\n    } else {\n      // Sort by default\n      fullSort.push({\n        field: group.field,\n        dir: group.dir || 'asc'\n      });\n    }\n  });\n\n  // Then original sort instructions are added\n  fullSort = fullSort.concat(sortArray);\n\n  return fullSort;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/sort.js\n **/","import * as aggregations from './aggregations';\nimport * as dataItems from './data-items';\nexport const kendo2es = _kendo2es;\nexport const es2kendo = _es2kendo;\n\n// Transform kendo groups declaration into ES bucket aggregations\nfunction _kendo2es(aggs, groups, fields, nestedFields, esMappingKey, filter) {\n  let previousLevelAggs = [aggs];\n  let previousLevelNestedPath = null;\n  groups.forEach(group => {\n    const field = fields[group.field];\n    const nextLevelAggs = _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter);\n\n    const aggs = {};\n    if (field.esNestedPath && field.esNestedPath.indexOf(previousLevelNestedPath) !== 0) {\n      aggs[field.esNestedPath + '_nested'] = aggs[field.esNestedPath + '_nested'] || {\n        nested: {\n          path: field.esFullNestedPath\n        },\n        aggs: {}\n      };\n      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_group'] = nextLevelAggs.group;\n      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_missing'] = nextLevelAggs.missing;\n    } else {\n      aggs[group.field + '_group'] = nextLevelAggs.group;\n      aggs[group.field + '_missing'] = nextLevelAggs.missing;\n    } // 3rd case for nested path that is not child of the previous group\n\n    previousLevelAggs.forEach(previousLevelAgg => {\n      Object.keys(aggs).forEach(aggKey => {\n        previousLevelAgg[aggKey] = aggs[aggKey];\n      });\n    });\n    previousLevelAggs = Object.keys(nextLevelAggs).map(aggKey => {\n      return nextLevelAggs[aggKey].aggregations;\n    });\n    previousLevelNestedPath = field.esNestedPath;\n  });\n}\n\nfunction _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter) {\n  const field = fields[group.field];\n  const groupAgg = {};\n  const missingAgg = {};\n\n  // Look for a aggregate defined on group field\n  // Used to customize the bucket aggregation for range, histograms, etc.\n  let fieldAggregate;\n  const groupAggregates = [];\n  (group.aggregates || []).forEach(aggregate => {\n    // We exclude strings that are not concerned by specific aggregations (only terms buckets)\n    // And cause bugs when counting cardinality on own group.\n    if (aggregate.field === group.field && field.type !== 'string') {\n      fieldAggregate = aggregate;\n    } else {\n      groupAggregates.push(aggregate);\n    }\n  });\n\n  if (fieldAggregate) {\n\n    // We support date histogramms if a 'interval' key is passed\n    // to the group definition\n    groupAgg[fieldAggregate.aggregate] = {\n      field: field.esAggName\n    };\n    if (fieldAggregate.interval) {\n      groupAgg[fieldAggregate.aggregate].interval = fieldAggregate.interval;\n    }\n  } else {\n\n    // Default is a term bucket aggregation\n    // if used on a not analyzed field or subfield\n    // it will create a group for each value of the field\n    groupAgg.terms = {\n      field: field.esAggName,\n      size: 0\n    };\n  }\n\n  missingAgg.missing = {\n    field: field.esAggName\n  };\n\n  const esGroupAggregates = aggregations.kendo2es(\n    groupAggregates,\n    fields,\n    nestedFields,\n    esMappingKey,\n    filter,\n    field.esNestedPath\n  );\n  groupAgg.aggregations = esGroupAggregates;\n  missingAgg.aggregations = esGroupAggregates;\n\n  return {\n    group: groupAgg,\n    missing: missingAgg\n  };\n}\n\n// Extraction aggregations from ES query result that will be used to group\n// data items\nfunction _parseGroupAggregations(aggregations, missingNested) {\n  let groupAggregations = Object.keys(aggregations).filter(aggKey => {\n    return aggKey.substr(aggKey.length - 6) === '_group';\n  }).map(aggKey => {\n    const fieldKey = aggKey.substr(0, aggKey.length - 6);\n    if (missingNested) {\n      aggregations[fieldKey + '_missing'].doc_count += missingNested;\n    }\n    return {\n      group: aggregations[aggKey],\n      missing: aggregations[fieldKey + '_missing'],\n      fieldKey: fieldKey\n    };\n  });\n\n  // extract other group aggregations from nested aggregations\n  Object.keys(aggregations)\n    .filter(aggKey => aggKey.substr(aggKey.length - 7) === '_nested')\n    .forEach(aggKey => {\n      // 'missing' count on a nested group aggregation =\n      //      'document without nested objects' + 'nested objects with missing field'\n      // and 'document without nested objects' is equal to 'number of documents' - 'number of nested documents'\n      const missingNested = aggregations.doc_count - aggregations[aggKey].doc_count;\n      groupAggregations =\n        groupAggregations.concat(_parseGroupAggregations(aggregations[aggKey], missingNested));\n    });\n\n  return groupAggregations;\n}\n\n// Transform ES bucket aggregations into kendo groups of data items\n// See doc here for format of groups:\n// http://docs.telerik.com/KENDO-UI/api/javascript/data/datasource#configuration-schema.groups\nfunction _es2kendo(items, aggregations, fields, aggregationsOnly) {\n  let allGroups = [];\n  if (aggregations) {\n    const groupAggregations = _parseGroupAggregations(aggregations);\n\n    // Find aggregations that are grouping aggregations (ie buckets in ES)\n    groupAggregations.forEach(groupAggregation => {\n      let groups = [];\n\n      const groupDefs = _esAgg2kendo(\n        groupAggregation.group,\n        groupAggregation.missing,\n        groupAggregation.fieldKey);\n\n      if (!aggregationsOnly) {\n        // Then distribute the data items in the groups\n        groups = dataItems.fillInGroups(groupDefs, items, fields[groupAggregation.fieldKey]);\n      } else {\n        groups = groupDefs.keys.map(function (key) {\n          return groupDefs.map[key];\n        });\n      }\n\n      // Case when there is subgroups. Solve it recursively.\n      let hasSubgroups = false;\n      if (groupAggregation.group.buckets && groupAggregation.group.buckets[0]) {\n        Object.keys(groupAggregation.group.buckets[0]).forEach(bucketKey => {\n          if (bucketKey.substr(bucketKey.length - 6) === '_group' ||\n            bucketKey.substr(bucketKey.length - 7) === '_nested') {\n            hasSubgroups = true;\n          }\n        });\n      }\n      groups.forEach(group => {\n        if (hasSubgroups) {\n          group.hasSubgroups = true;\n          group.items = _es2kendo(group.items, group.bucket, fields, aggregationsOnly);\n        }\n        delete group.bucket;\n      });\n\n      allGroups = allGroups.concat(groups);\n    });\n  }\n\n  return allGroups;\n}\n\n// Transform a single bucket aggregation into kendo groups definitions\n// Does not fill up the data items\nfunction _esAgg2kendo(groupAggregation, missingAggregation, fieldKey) {\n  const groupsMap = {};\n  const groupKeys = [];\n\n  // Each bucket in ES aggregation result is a group\n  groupAggregation.buckets.forEach(bucket => {\n    const bucketKey = bucket.key_as_string || bucket.key;\n    groupKeys.push(bucketKey);\n    groupsMap[bucketKey] = {\n      field: fieldKey,\n      value: bucketKey,\n      hasSubgroups: false,\n      aggregates: aggregations.es2kendo(bucket),\n      items: [],\n      bucket: bucket\n    };\n    groupsMap[bucketKey].aggregates[fieldKey] = {\n      count: bucket.doc_count\n    };\n  });\n\n  // Special case for the missing value\n  groupsMap[''] = {\n    field: fieldKey,\n    value: '',\n    hasSubgroups: false,\n    aggregates: aggregations.es2kendo(missingAggregation),\n    items: [],\n    bucket: missingAggregation\n  };\n  groupsMap[''].aggregates[fieldKey] = {\n    count: missingAggregation.doc_count\n  };\n\n  return {\n    map: groupsMap,\n    keys: groupKeys\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/groups.js\n **/","import * as esUtils from './es-utils';\nexport const kendo2es = _kendo2es;\nexport const es2kendo = _es2kendo;\n\nconst kendoToESAgg = {\n  count: 'cardinality',\n  min: 'min',\n  max: 'max',\n  sum: 'sum',\n  average: 'avg'\n};\n\n// Transform kendo aggregates into ES metric aggregations\nfunction _kendo2es(aggregate = [], fields, nestedFields, esMappingKey, filter, groupNestedPath) {\n  const esAggs = {};\n\n  aggregate.forEach(aggItem => {\n    const field = fields[aggItem.field];\n    let nestedPath = field.esNestedPath;\n    let aggsWrapper = esAggs;\n    if (groupNestedPath !== nestedPath) {\n      const previousPathParts = [];\n      if (groupNestedPath && nestedPath.indexOf(groupNestedPath) !== 0) {\n        esAggs.group_reverse_nested = esAggs.group_reverse_nested || {\n          reverse_nested: {},\n          aggregations: {}\n        };\n        aggsWrapper = esAggs.group_reverse_nested.aggregations;\n      } else if (groupNestedPath) {\n        nestedPath = nestedPath.substr(groupNestedPath.length + 1, nestedPath.length);\n      }\n\n      nestedPath.split('.').forEach(nestedPathPart => {\n        previousPathParts.push(nestedPathPart);\n        const currentPath = groupNestedPath ?\n          groupNestedPath + '.' + previousPathParts.join('.') :\n          previousPathParts.join('.');\n        const fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n        const currentFields = nestedFields[currentPath];\n        if (!currentFields) return;\n        if (!aggsWrapper[currentPath]) {\n          aggsWrapper[currentPath + '_filter_nested'] = aggsWrapper[currentPath + '_filter_nested'] || {\n            nested: {\n              path: fullCurrentPath\n            },\n            aggregations: {}\n          };\n          aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] =\n            aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] || {\n              filter: esUtils.innerHitsFilter(fullCurrentPath, null, filter),\n              aggregations: {}\n            };\n        }\n        aggsWrapper = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'].aggregations;\n      });\n    }\n\n    aggsWrapper[aggItem.field + '_' + aggItem.aggregate] = {};\n    aggsWrapper[aggItem.field + '_' + aggItem.aggregate][kendoToESAgg[aggItem.aggregate]] = {\n      field: field.esAggName\n    };\n  });\n\n  return esAggs;\n}\n\n// Transform aggregation results from a ES query to kendo aggregates\nfunction _es2kendo(aggregations = {}, aggregates = {}) {\n  Object.keys(aggregations).forEach(aggKey => {\n    if (!aggregations[aggKey]) return;\n    ['count', 'min', 'max', 'average', 'sum'].forEach(aggType => {\n      const suffixLength = aggType.length + 1;\n      if (aggKey.substr(aggKey.length - suffixLength) === '_' + aggType) {\n        const fieldKey = aggKey.substr(0, aggKey.length - suffixLength);\n        aggregates[fieldKey] = aggregates[fieldKey] || {};\n        aggregates[fieldKey][aggType] = aggregations[aggKey].value;\n      }\n    });\n\n    if (aggKey.substr(aggKey.length - 7) === '_nested' || aggKey.substr(aggKey.length - 7) === '_filter') {\n      // recursivity on intermediate levels\n      _es2kendo(aggregations[aggKey], aggregates);\n    }\n\n  });\n  return aggregates;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/aggregations.js\n **/","// Some function that work on ES queries to deal with nested levels and other\n// difficulties\n\nexport const innerHits = _innerHits;\nexport const innerHitsFilter = _innerHitsFilter;\n\n// Get a root inner_hits definition to fetch all nested/parent/child docs\nfunction _innerHits(nestedFields, esMappingKey, subTypes, sort, filter) {\n  const innerHits = {};\n  Object.keys(nestedFields).forEach(nestedPath => {\n    let previousLevelInnerHits = innerHits;\n    const previousPathParts = [];\n    nestedPath.split('.').forEach(nestedPathPart => {\n      previousPathParts.push(nestedPathPart);\n      const currentPath = previousPathParts.join('.');\n      const fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n      const currentFields = nestedFields[currentPath];\n      if (!currentFields) {\n        return;\n      }\n      if (!previousLevelInnerHits[currentPath]) {\n        previousLevelInnerHits[currentPath] = {\n          path: {\n            [fullCurrentPath]: {\n              _source: currentFields,\n              size: 10000,\n              sort: sort,\n              query: {\n                filtered: {\n                  filter: _innerHitsFilter(fullCurrentPath, null, filter)\n                }\n              }\n            }\n          }\n        };\n      }\n      if (currentPath !== nestedPath) {\n        previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits =\n          previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits || {};\n        previousLevelInnerHits =\n          previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits;\n      }\n    });\n  });\n\n  Object.keys(subTypes).forEach(subType => {\n    const currentFields = subTypes[subType];\n    innerHits[subType] = {\n      type: {\n        [subType]: {\n          _source: currentFields,\n          size: 10000,\n          sort: sort,\n          query: {\n            filtered: {\n              filter: _innerHitsFilter(null, subType, filter)\n            }\n          }\n        }\n      }\n    };\n  });\n  return innerHits;\n}\n\nfunction _manageBooleanFilter(nestedPath, subType, booleanFilter) {\n  return booleanFilter\n    .filter(childFilter => {\n      return (childFilter.bool && childFilter.bool.must) || (childFilter.bool && childFilter.bool.should) ||\n        (childFilter.nested && childFilter.nested.path === nestedPath) ||\n        (childFilter.not && childFilter.not.nested && childFilter.not.nested.path === nestedPath) ||\n        (childFilter.has_child && childFilter.has_child.type === subType) ||\n        (childFilter.not && childFilter.not.has_child && childFilter.not.has_child.type === subType) ||\n        (childFilter.has_parent && childFilter.has_parent.type === subType) ||\n        (childFilter.not && childFilter.not.has_parent && childFilter.not.has_parent.type === subType);\n    })\n    .map(childFilter => {\n      if (childFilter.nested) {\n        return childFilter.nested.filter;\n      } else if (childFilter.not && childFilter.not.nested) {\n        return {\n          not: childFilter.not.nested.filter\n        };\n      } else if (childFilter.has_child) {\n        return childFilter.has_child.filter;\n      } else if (childFilter.not && childFilter.not.has_child) {\n        return {\n          not: childFilter.not.has_child.filter\n        };\n      } else if (childFilter.has_parent) {\n        return childFilter.has_parent.filter;\n      } else if (childFilter.not && childFilter.not.has_parent) {\n        return {\n          not: childFilter.not.has_parent.filter\n        };\n      } else {\n        return _innerHitsFilter(nestedPath, childFilter);\n      }\n    });\n}\n\n// Traverse the filter to keep only the parts that concern\n// a nesting path\nfunction _innerHitsFilter(nestedPath, subType, filter) {\n  filter = $.extend(true, {}, filter);\n  if (filter.bool && filter.bool.must) {\n    filter.bool.must = _manageBooleanFilter(nestedPath, subType, filter.bool.must);\n  }\n\n  if (filter.bool && filter.bool.should) {\n    filter.bool.should = _manageBooleanFilter(nestedPath, subType, filter.bool.should);\n  }\n\n  return filter;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/es-utils.js\n **/","export const fillInGroups = _fillInGroups;\nexport const fromHits = _fromHits;\n\n// distribute data items in groups based on a field value\nfunction _fillInGroups(groupDefs, dataItems, field) {\n  const groups = [];\n  dataItems.forEach(function (dataItem) {\n    let group = groupDefs.map[dataItem[field.key] || ''];\n\n    // If no exact match, then we may be in some range aggregation ?\n    if (!group) {\n      const fieldValue = field.type === 'date' ? new Date(dataItem[field.key]) : dataItem[field.key];\n\n      for (let i = 0; i < groupDefs.keys.length; i++) {\n        const groupDefValue = field.type === 'date' ? new Date(groupDefs.keys[i]) : groupDefs.keys[i];\n        if (fieldValue >= groupDefValue) {\n          const groupDefNextValue = groupDefs.keys[i + 1] && (field.type === 'date' ?\n            new Date(groupDefs.keys[i + 1]) : groupDefs.keys[i + 1]);\n          if (!groupDefNextValue || fieldValue < groupDefNextValue) {\n            group = groupDefs.map[groupDefs.keys[i]];\n          }\n        }\n      }\n    }\n\n    if (!group) {\n      throw new Error('No group found, val: ' + dataItem[field.key] + ' field: ' + field.key);\n    }\n    group.items.push(dataItem);\n    if (group.items.length === 1) {\n      groups.push(group);\n    }\n  });\n  return groups;\n}\n\n// Mimic fetching values from _source as the 'fields' functionality\n// would have done it.\n// We do not use the native 'fields' due to this bug:\n// https://github.com/elastic/elasticsearch/issues/14475\nfunction _getValuesFromSource(source, pathParts) {\n  let values = [];\n  const value = source[pathParts[0]];\n  if (value === undefined) {\n    return [];\n  }\n\n  if (pathParts.length > 1) {\n\n    // recursivity is not over, there remain some path parts\n    if ($.isArray(value)) {\n      value.forEach(function (valueItem) {\n        values = values.concat(_getValuesFromSource(valueItem, pathParts.slice(1)));\n      });\n    } else {\n      values = _getValuesFromSource(value, pathParts.slice(1));\n    }\n  } else {\n\n    // recursivity, we should be in a leaf value\n    if ($.isArray(value)) {\n      values = value;\n    } else {\n      values = [value];\n    }\n  }\n  return values;\n}\n\n// Transform hits from the ES query in to data items for kendo grid\n// The difficulty is that hits can contain inner hits and that some\n// fields can be multi-valued\nfunction _fromHits(hits, fields, innerPath) {\n\n  let dataItems = [];\n  hits.forEach(hit => {\n    const hitSource = hit._source || {};\n    const dataItem = {};\n\n    dataItem.id = [hit._id];\n    Object.keys(fields).filter(fieldKey => {\n      const field = fields[fieldKey];\n\n      // Keep only the fields that are part of this nested/parent/child\n      if (innerPath === undefined) {\n        return !(field.esNestedPath || field.esChildType || field.esParentType);\n      } else {\n        return field.esNestedPath === innerPath ||\n          field.esChildType === innerPath ||\n          field.esParentType === innerPath;\n      }\n    }).forEach(function (fieldKey) {\n      const field = fields[fieldKey];\n      let values = _getValuesFromSource(hitSource, field.esNameSplit);\n\n      // special case field that is a date deep down by displayed as a number\n      if (field.duration) {\n        if (!moment) {\n          throw new Error('Working on durations requires to load momentjs library');\n        }\n      }\n\n      if (field.duration === 'beforeToday') {\n        values = values.map(value => {\n          return moment().startOf('day').diff(moment(value).startOf('day'), 'days');\n        });\n      }\n\n      if (field.duration === 'afterToday') {\n        values = values.map(value => {\n          return moment(value).startOf('day').diff(moment().startOf('day'), 'days');\n        });\n      }\n\n      if (values) {\n        if (field.esMultiSplit) {\n          if (values && values.length) {\n            dataItem[fieldKey] = values;\n          } else {\n            dataItem[fieldKey] = [null];\n          }\n        } else {\n          dataItem[fieldKey] = values.join(field.esMultiSeparator || '\\n');\n        }\n      }\n    });\n\n    // Multiply and fill items based on nesting levels\n    let splittedItems = [dataItem];\n    Object.keys(hit.inner_hits || {}).forEach(function (innerHitKey) {\n      const nestedItems =\n        _fromHits(hit.inner_hits[innerHitKey].hits.hits, fields, innerHitKey);\n      const newSplittedDataItems = [];\n      splittedItems.forEach(function (splittedItem) {\n        if (nestedItems.length) {\n          nestedItems.forEach(function (nestedItem) {\n            const mergedItem = {};\n            Object.keys(nestedItem).forEach(function (key) {\n              mergedItem[key] = nestedItem[key];\n            });\n            Object.keys(splittedItem).forEach(function (key) {\n              mergedItem[key] = splittedItem[key];\n            });\n            newSplittedDataItems.push(mergedItem);\n          });\n        } else {\n          newSplittedDataItems.push(splittedItem);\n        }\n      });\n      splittedItems = newSplittedDataItems;\n    });\n\n    dataItems = dataItems.concat(splittedItems);\n\n  });\n  return _splitMultiValues(dataItems);\n}\n\n// Split lines of data items based on their optionally multipl items\n// Example: [{a:[1,2],b:[3]}] -> [{a:1,b:3},{a:2,b:3}]\nfunction _splitMultiValues(items) {\n  let results = [];\n\n  // Iterates on items in the array and multiply based on multiple values\n  items.forEach(item => {\n    let itemResults = [{}];\n\n    // Iterate on properties of item\n    Object.keys(item).forEach(k => {\n      const partialItemResults = [];\n\n      // Iterate on the multiple values of this property\n      if (item[k] && item[k].constructor === Array) {\n        item[k].forEach(val => {\n          itemResults.forEach(result => {\n\n            // Clone the result to create variants with the different values of current key\n            const newResult = {};\n            Object.keys(result).forEach(k2 => newResult[k2] = result[k2]);\n            newResult[k] = val;\n            partialItemResults.push(newResult);\n          });\n        });\n      } else {\n        itemResults.forEach(result => {\n          result[k] = item[k];\n          partialItemResults.push(result);\n        });\n      }\n      itemResults = partialItemResults;\n    });\n\n    results = results.concat(itemResults);\n  });\n  return results;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/data-items.js\n **/","export const kendo2es = _kendo2es;\n\n// Transform a tree of kendo filters into a tree of ElasticSearch filters\nfunction _kendo2es(kendoFilters, fields, initOptions) {\n  let filters;\n\n  // logicalConnective can be \"and\" or \"or\"\n  let logicalConnective = 'and';\n\n  if (kendoFilters.operator) {\n    filters = [kendoFilters];\n  } else if (kendoFilters.logic) {\n    logicalConnective = kendoFilters.logic;\n    filters = kendoFilters.filters || [];\n  } else if (kendoFilters.constructor === Array) {\n    filters = kendoFilters;\n  } else {\n    throw new Error('Unsupported filter object: ' + kendoFilters);\n  }\n\n  const esFilters = [];\n  const esNestedFilters = {};\n\n  filters.forEach(filter => {\n    if (filter.logic) {\n      esFilters.push(_kendo2es(filter, fields));\n    } else {\n      const field = fields[filter.field];\n      if (!field) {\n        throw new Error('Unknown field in filter: ' + filter.field);\n      }\n      let esFilter;\n      try {\n        esFilter = {\n          query: {\n            query_string: {\n              query: _filterParam(filter, fields, initOptions),\n              // support uppercase/lowercase and accents\n              analyze_wildcard: true\n            }\n          }\n        };\n      } catch (error) {\n        if (error.message === 'missing filter is not supported on nested fields') {\n          esFilter = {\n            not: {\n              nested: {\n                path: field.esNestedPath,\n                filter: {\n                  exists: {\n                    field: field.esSearchName\n                  }\n                }\n              }\n            }\n          };\n        } else {\n          throw error;\n        }\n      };\n\n      if (field.esNestedPath && !esFilter.not) {\n        const esNestedFilter = esNestedFilters[field.esNestedPath] || {\n          nested: {\n            path: field.esFullNestedPath,\n            filter: {\n              bool: {}\n            }\n          }\n        };\n\n        switch (logicalConnective) {\n          case 'and': {\n            esNestedFilter.nested.filter.bool.must = esNestedFilter.nested.filter.bool.must || [];\n            esNestedFilter.nested.filter.bool.must.push(esFilter);\n            break;\n          }\n\n          case 'or': {\n            esNestedFilter.nested.filter.bool.should = esNestedFilter.nested.filter.bool.should || [];\n            esNestedFilter.nested.filter.bool.should.push(esFilter);\n            break;\n          }\n        }\n\n        if (!esNestedFilters[field.esNestedPath]) {\n          esFilter = esNestedFilters[field.esNestedPath] = esNestedFilter;\n        } else {\n          esFilter = null;\n        }\n      } else if (field.esParentType) {\n        esFilter = {\n          has_parent: {\n            type: field.esParentType,\n            filter: esFilter\n          }\n        };\n      } else if (field.esChildType) {\n        esFilter = {\n          has_child: {\n            type: field.esChildType,\n            filter: esFilter\n          }\n        };\n      }\n\n      if (esFilter) {\n        esFilters.push(esFilter);\n      }\n\n    }\n  });\n\n  const result = {\n    bool: {}\n  };\n  switch (logicalConnective) {\n    case 'and': {\n      result.bool.must = esFilters;\n      break;\n    }\n\n    case 'or': {\n      result.bool.should = esFilters;\n      break;\n    }\n  }\n\n  return result;\n}\n\n// Transform a single kendo filter in a string\n// that can be used to compose a ES query_string query\nfunction _filterParam(kendoFilter, fields, initOptions) {\n\n  // Boolean filter seems to forget the operator sometimes\n  kendoFilter.operator = kendoFilter.operator || 'eq';\n\n  // Use the filter field name except for contains\n  // that should use classical search instead of regexp\n  const field = fields[kendoFilter.field];\n\n  // special case field that is a date deep down by displayed as a number\n  if (field.duration) {\n    if (!moment) {\n      throw new Error('Working on durations requires to load momentjs library');\n    }\n  }\n\n  if (field.duration === 'beforeToday') {\n    kendoFilter.value = moment().startOf('day').subtract(kendoFilter.value, 'days').format();\n    if (kendoFilter.operator === 'lt') kendoFilter.operator = 'gt';\n    else if (kendoFilter.operator === 'lte') kendoFilter.operator = 'gte';\n    else if (kendoFilter.operator === 'gt') kendoFilter.operator = 'lt';\n    else if (kendoFilter.operator === 'gte') kendoFilter.operator = 'lte';\n  }\n\n  if (field.duration === 'afterToday') {\n    kendoFilter.value = moment().startOf('day').add(kendoFilter.value, 'days').format();\n  }\n\n  let fieldName;\n  if (kendoFilter.operator === 'search') {\n    fieldName = field.esSearchName;\n  } else {\n    fieldName = field.esFilterName;\n  }\n\n  const fieldEscaped = _asESParameter(fieldName);\n  const valueEscaped = _asESParameter(kendoFilter.value, kendoFilter.operator);\n\n  const simpleBinaryOperators = {\n    eq: '',\n    search: '',\n    lt: '<',\n    lte: '<=',\n    gt: '>',\n    gte: '>='\n  };\n\n  if (simpleBinaryOperators[kendoFilter.operator] !== void 0) {\n    const esOperator = simpleBinaryOperators[kendoFilter.operator];\n    // Optional special condition, when comparing against bool false values\n    // we treat also the missing property condition, like this, false === missing too\n    // Event if this is not true, normally is the desired effect\n    if (initOptions && initOptions.missingBooleanAsFalse === true && kendoFilter.value === false) {\n      return (fieldEscaped + ':' + esOperator + valueEscaped) + ' OR _missing_:' + fieldEscaped;\n    } else {\n      return fieldEscaped + ':' + esOperator + valueEscaped;\n    }\n  } else {\n    let expression;\n    switch (kendoFilter.operator) {\n      case 'neq':\n        return 'NOT (' + fieldEscaped + ':' + valueEscaped + ')';\n      case 'contains':\n        return '(' + fieldEscaped + ':*' + valueEscaped + '*)';\n      case 'doesnotcontain':\n        return 'NOT (' + fieldEscaped + ':*' + valueEscaped + '*)';\n      case 'startswith':\n        return fieldEscaped + ':' + valueEscaped + '*';\n      case 'endswith':\n        return fieldEscaped + ':*' + valueEscaped;\n      case 'missing':\n        if (field.esNestedPath || field.esParentType || field.esChildType) {\n          // missing in a nested document should be implemented as a \"not nested exists\"\n          // but this is not really doable when mixing with other filters\n          // see https://github.com/elastic/elasticsearch/issues/3495\n          throw new Error('missing filter is not supported on nested fields');\n        }\n        expression = '_missing_:' + fieldEscaped;\n        if (field.type === 'string') {\n          expression += ' OR (' + fieldEscaped + ':\"\")';\n        }\n        return expression;\n      case 'exists':\n        expression = '_exists_:' + fieldEscaped;\n        if (field.type === 'string') {\n          expression += ' AND NOT(' + fieldEscaped + ':\"\")';\n        }\n        return expression;\n      default:\n        throw new Error('Unsupported Kendo filter operator: ' + kendoFilter.operator);\n    }\n  }\n}\n\n// Escape values so that they are suitable as an elasticsearch query_string query parameter\nconst escapeValueRegexp = /[+\\-&|!()\\{}\\[\\]^:\"~*?:\\/ ]/g;\nconst escapeSearchValueRegexp = /[+\\-&|!()\\{}\\[\\]^:~:\\/]/g;\n\nfunction _asESParameter(value, operator) {\n  if (value.constructor === Date) {\n    value = value.toISOString();\n  } else if (typeof value === 'boolean' || typeof value === 'number') {\n    value = '' + value;\n  }\n\n  // For the special 'search' operator we allow some wildcard and other characters\n  if (operator === 'search') {\n    value = value.replace('\\\\', '\\\\\\\\');\n    if (((value.match(/\"/g) || []).length % 2) === 1) {\n      value = value.replace(/\"/g, '\\\\\"');\n    }\n    value = value.replace(escapeSearchValueRegexp, '\\\\$&');\n    return value;\n  }\n  return value.replace('\\\\', '\\\\\\\\').replace(escapeValueRegexp, '\\\\$&');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/filters.js\n **/","export const fromMapping = _fromMapping;\nexport const fill = _fill;\nexport const nestedFields = _nestedFields;\n\n// Transform a mapping definition from ElasticSearch into a kendo fields map\n// This utility function is exposed as it can be interesting to use it before instantiating\n// the actual datasource\n// @param mapping - An elasticsearch mapping\nfunction _fromMapping(\n  mapping, model, fields = {}, prefix = '', esPrefix, nestedPath) {\n  Object.keys(mapping.properties || {}).forEach(propertyKey => {\n    const property = mapping.properties[propertyKey];\n    const curedPropertyKey = asKendoPropertyKey(propertyKey);\n    const prefixedName = prefix ? prefix + '_' + curedPropertyKey : curedPropertyKey;\n    const esName = esPrefix ? esPrefix + '.' + propertyKey : propertyKey;\n\n    if (property.type === 'nested') {\n      // Case where the property is a nested object\n      const subNestedPath = nestedPath ? nestedPath + '.' + esName : esName;\n      _fromMapping(property, model, fields, prefixedName, '', subNestedPath);\n    } else if (property.properties) {\n      // Case where the property is a non nested object with properties\n      _fromMapping(property, model, fields, prefixedName, esName, nestedPath);\n    } else if (property.type === 'object') {\n      // Case where the property is a non nested object with zero subproperties. do nothing.\n    } else {\n      // Finally case of a leaf property\n      const field = fields[prefixedName] = fields[prefixedName] || {};\n\n      // if the field was already defined with a nested path,\n      // then we are in the case of field both nested and included in parent\n      // then we should not consider it as a real leaf property\n      if (!field.esNestedPath) {\n        field.type = field.type || property.type;\n\n        // ES supports a variety of numeric types. In JSON and kendo it is simply 'number'.\n        if (['float', 'double', 'integer', 'long', 'short', 'byte'].indexOf(field.type) !== -1) {\n          field.type = 'number';\n        }\n\n        // Default is splitting data lines except for string fields\n        if (field.type !== 'string') {\n          field.esMultiSplit = true;\n        }\n\n        if (nestedPath) {\n          field.esNestedPath = nestedPath;\n        }\n        field.esName = esName;\n\n        // When the field is not analyzed, the default string subfields should not be applied.\n        if (property.index === 'not_analyzed') {\n          field.esSearchSubField = null;\n          field.esFilterSubField = null;\n          field.esAggSubField = null;\n        }\n      }\n    }\n  });\n\n  _fill(fields, model);\n\n  return fields;\n};\n\n// Associate Kendo field names to ElasticSearch field names.\n// We have to allow ElasticSearch field names to be different\n// because ES likes an \"@\" and/or dots in field names while Kendo fails on that.\n// Filtering and aggregating can be based on a a different field if esFilterName\n// or esAggName are defined or on a subfield if esFilterSubField or esAggSubField are defined.\n// Typical use case is the main field is analyzed, but it has a subfield that is not\n// (or only with a minimal analyzer)\nfunction _fill(fields, model = {}) {\n  for (const k in fields) {\n    if (fields.hasOwnProperty(k)) {\n      const field = fields[k];\n      field.key = k;\n      field.esName = field.esName || k;\n      field.esNameSplit = field.esName.split('.');\n      if (field.esNestedPath) {\n        field.esFullNestedPath = field.esNestedPath;\n        if (model.esMappingKey) {\n          field.esFullNestedPath = model.esMappingKey + '.' + field.esFullNestedPath;\n        }\n      }\n      if (!field.esSearchName) {\n        field.esSearchName = field.esName;\n        if (field.hasOwnProperty('esSearchSubField')) {\n          if (field.esSearchSubField) {\n            field.esSearchName += '.' + field.esSearchSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.search) {\n          field.esSearchName += '.' + model.esStringSubFields.search;\n        }\n        if (field.esNestedPath) {\n          field.esSearchName = field.esNestedPath + '.' + field.esSearchName;\n        }\n      }\n      if (!field.esFilterName) {\n        field.esFilterName = field.esName;\n        if (field.hasOwnProperty('esFilterSubField')) {\n          if (field.esFilterSubField) {\n            field.esFilterName += '.' + field.esFilterSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.filter) {\n          field.esFilterName += '.' + model.esStringSubFields.filter;\n        }\n        if (field.esNestedPath) {\n          field.esFilterName = field.esNestedPath + '.' + field.esFilterName;\n        }\n      }\n      if (!field.esAggName) {\n        field.esAggName = field.esName;\n        if (field.hasOwnProperty('esAggSubField')) {\n          if (field.esAggSubField) {\n            field.esAggName += '.' + field.esAggSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.agg) {\n          field.esAggName += '.' + model.esStringSubFields.agg;\n        }\n        if (field.esNestedPath) {\n          field.esAggName = field.esFullNestedPath + '.' + field.esAggName;\n        }\n      }\n    }\n  }\n}\n\n// Get a property key and transform it in a suitable key for kendo\n// the constraint is that kendo needs a key suitable for javascript object's dot notation\n// i.e a valid js identifier with alphanumeric chars + '_' and '$'\nfunction asKendoPropertyKey(value) {\n  return value.replace(/[^a-zA-z0-9_$]/g, '_');\n}\n\n// Get sets of nesting levels and matching groups of fields\nfunction _nestedFields(fields) {\n  const _result = {};\n  const _subTypes = {};\n  Object.keys(fields).forEach(fieldKey => {\n    const field = fields[fieldKey];\n    if (field.esNestedPath) {\n      _result[field.esNestedPath] = _result[field.esNestedPath] || [];\n      _result[field.esNestedPath].push(field.esName);\n    }\n    if (field.esParentType) {\n      _subTypes[field.esParentType] = _subTypes[field.esParentType] || [];\n      _subTypes[field.esParentType].push(field.esName);\n    }\n    if (field.esChildType) {\n      _subTypes[field.esChildType] = _subTypes[field.esChildType] || [];\n      _subTypes[field.esChildType].push(field.esName);\n    }\n  });\n\n  return [_result, _subTypes];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/Florent CT/projects/kendo-elasticsearch/~/eslint-loader!./src/fields.js\n **/"],"sourceRoot":""}